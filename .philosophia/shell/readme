SHell 的最最基础的内容，三个字就足够：字节流。我们首先需要关注的也只有其中的特殊情况：字符流，或者叫文本流。

从这里开始，得到从最基础处开始说起的包含一切关键之要点的有关 SHell 的整个脉络。

SHell 一条语句本身是什么，是文本流的特殊情况：字符串。语句描述了要执行的任务。一条语句有三个部分，命名参数序列、命令名称、匿名参数序列（args）。除了命令名称外，另外两部分都可选。这三个部分，都是字符串值。一切都是字符串，不存在数字也不存在布尔。

由于你直接写的代码就已经是这个语言里的字符串值，所以为了能够表达复杂语义，有的字符串就要当做有特殊效果来对待，必须转义才能变成普通字符串值。比如空格符、转义符本身、括号、波浪线、插值符、重定向符等。转义符有两种，一种是一次作用于一个字符的反斜线，一种是一次作用于一段字符串的引号。其中引号中的双引号单引号的区别在于，前者不会转义插值语义的部分后者会转义、后者转义所有字符。连续的一个或多个未被转义的空格，会作为一条语句中的每个字段的分割符号。所有特殊字符的作用都建议自行举一反三来探索。

有一个特殊命令，名称为单个冒号，即 : 。它会无视传入的命名或匿名参数并什么都不做然后以固定退出码 0 来退出。

每条语句结尾要有结尾符。有 ; 和 && 和 || 这么仨可选，分别表示：执行完上一条语句不论如何都执行下一条语句（默认配置）、执行完上一条语句退出码 0 （语义为无异常）才执行下一条语句、执行完上一条语句退出码非 0 （语义为有异常）才执行下一条语句。在一条语句的开头增加叹号，可以反转语句执行完后的退出码。

分支控制怎么做？由于没有布尔值，因此 SHell 实际不存在分支语义。我们只能用异常处理语义实现分支的效果。关键字 if-then 的语义是异常处理，不是逻辑控制，但用起来的样子（语法）被做成了其它语言里逻辑控制的风格。

多条语句可以组合为一段语句，组合手段为括号。花括号不会创建子进程（子环境）而是在当前环境运行影响当前环境，圆括号会创建独立的子进程环境在其中运行，子进程环境会在运行完后自动销毁。在 SHell 一次必须提交完整的一段语句。一段语句的结尾符只有分号 ; ，另外两个一条语句的结尾符无法结束一段语句因而不被视为一次完整的提交，因此，即便打回车多个也不会提交命令并触发解释和执行。如果末尾没有分号，且成对括号完整，则分号会在提交后的解释中被自动补充。

任何一段提交都会创建至少一个运行实例（进程），一个实例的创建依据就是命令名称所指的程序、与传入其中的命名与匿名参数。任何一个进程都有三个接口：标准输入（stdin, 0）一般用于数据或用户输入，标准输出（stdout, 1）一般用于提示信息输出或作为数据处理后的返回值输出，标准错误（stderr, 2）一般用于在前者用于返回输出时作为互不影响的实时提示信息输出。

一段语句一般包括，可以调度程序执行的代码部分（可能是一条或多条组合起来的语句），以及对标准输入、标准输出、标准错误三者的重定向描述。

管道符用于将左边一段语句的标准输出重定向到右边一段语句的标准输入。大于号用于指定本段语句的标准输出的重定向，小于号用于指定谁的标准输出被重定向到本段语句的标准输入，大于号 2 用于指定本段语句的标准错误的重定向。

SHell 中大部分进程的标准输入接口都支持流式传输，里「进来一条处理一条然后输出然后等待下一条进来」，典型的比如 awk 或 sed 或  grep 程序还有内置命令组合 while-read 。你可以在调用它们的时候，向它们的标准输入重定向一个永远不会结束的输出，你会发现它们都是接收一行处理一行再接收下一行这样，而不会等待所有输出都输出完才开始处理。

那么，如果允许使用换行符作为数据集的 record （行）的分隔、且不介意数据集被无结构化地表示（失去数据类型全序列化为如 CSV 格式的字符串），则一个流式处理数据集的功能在 SHell 上的实现将会非常简洁。

基本就是这样了。

然后，你将会发现，真正重要的三个工具不是那几个并非 SHell 作为语言的组成部分的，什么， awk sed grep 这些。它们是区别于 sh 的 **另外的工具** 。真正重要的三者，是 echo eval exec 。它们三个都直指着 SHell 这么个东西的它的本质：让客体知道「我是什么我究竟是个什么东西」、让再怎么客体的一层原本只能做值的内容也能像主体一样「能动起来行动起来」、以及让进行中的行动「共享相同的历史空间从而继承历史并夺未来」。

----""""

猫头鹰只在黄昏时起飞，本质的本质就在表面；正如问题包含了答案并且比答案还要更多。

而这里面， —— 我们现终可以光荣地称呼到：「这里并不存在主体的秘密」了。！！

